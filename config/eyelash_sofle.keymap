#define ZMK_POINTING_DEFAULT_MOVE_VAL 1200  // 600
#define ZMK_POINTING_DEFAULT_SCRL_VAL 25   // 10

#define L_BASE         0
#define L_TEST         1
#define L_COLEMAK      2

#define L_SYMNUM       3
#define L_NAV          4
#define L_SPECIAL      5
#define L_MOUSE        6 

#define L_JUMP         7 

// TODO: convert left ctrl and alt to right versions, where appropriate
// TODO maybe move the numbers to bottom row?
// idea: add 'one handed mode' layers. e.g. for arrow keys.

#include <input/processors.dtsi>
#include <zephyr/dt-bindings/input/input-event-codes.h>
#include <behaviors.dtsi>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/outputs.h>
#include <dt-bindings/zmk/pointing.h>
#include <dt-bindings/zmk/rgb.h>

&mmv_input_listener { input-processors = <&zip_xy_scaler 2 1>; };
&msc_input_listener { input-processors = <&zip_scroll_scaler 2 1>; };
&msc {
    acceleration-exponent = <1>;      // 0
    time-to-max-speed-ms = <100>;       // 300
    delay-ms = <0>;                   // 0
};
&mmv {
    time-to-max-speed-ms = <500>;
    acceleration-exponent = <1>;
    trigger-period-ms = <16>;
};
&soft_off { hold-time-ms = <2000>; };

/ {
    scroll_encoder: scroll_encoder {
        compatible = "zmk,behavior-sensor-rotate";
        #sensor-binding-cells = <0>;
        bindings = <&msc SCRL_DOWN>, <&msc SCRL_UP>;
        tap-ms = <100>;
    };
    behaviors {
         // test tap dance. prints 1 or 2 or 3
         td1: td1 {
            compatible = "zmk,behavior-tap-dance";
            #binding-cells = <0>;
            tapping-term-ms = <200>;
            bindings = <&kp N1>, <&kp N2>, <&kp N3>;
        };
         // bt selection tap dance. the point is to only trigger if really intentional. 1 press prints a dot or something. only triple click works
         // note: i call it 1 but internally it is zero based
         td_bt1: td_bt1 {
            compatible = "zmk,behavior-tap-dance";
            #binding-cells = <0>;
            tapping-term-ms = <200>;
            bindings = <&kp DOT>, <&kp DOT>, <&bt BT_SEL 0>;
        };
    };
    combos {
        compatible = "zmk,combos";
        softoff {
            bindings = <&soft_off>;
            key-positions = <14 28 40>;
        };
        // only active on base and testing layers
        // the key positions -- i counted them from below layout sections
        combo_jk {
            timeout-ms = <50>;
            key-positions = <30 34>;
            bindings = <&caps_word>;
            layers = <0 1>;
        };

        //  test if the key positions are correct. see glossary below
        combo_qw {
            timeout-ms = <50>;
            key-positions = <14 15>;
            bindings = <&kp X>;
            layers = <0 1>;
        };

        // named after the index finger position. the adjacent middle and ring fingers are also pressed
        // to mouse layer
        combo_mxx {
            timeout-ms = <50>;
            key-positions = <47 48 49>;
            bindings = <&to L_MOUSE>;
            //layers = <0 1>;
        };
        // to home layer 
        combo_hxx {
            timeout-ms = <50>;
            key-positions = <33 34 35>;
            bindings = <&to L_BASE>;
            //layers = <0 1>;
        };
        // one-off special/functions layer (aka sticky layer)
        combo_fxx {
            timeout-ms = <50>;
            key-positions = <28 29 30>;
            bindings = <&sl L_SPECIAL>;
            //layers = <0 1>;
        };
        // caps-word
        combo_wxx {
            timeout-ms = <50>;
            key-positions = <15 16 17>;
            bindings = <&caps_word>;
            //layers = <0 1>;
        };
    };

    // but just &kp LC(C) is simpler than macro_copy..
    macros {
    //    macro_copy: macro_copy {
    //    compatible = "zmk,behavior-macro";
    //    #binding-cells = <0>;
    //    bindings = <&kp LC(C)>;
    //    };
    //    macro_paste: macro_paste {
    //    compatible = "zmk,behavior-macro";
    //    #binding-cells = <0>;
    //    bindings = <&kp LC(V)>;
    //    };
    //    macro_cut: macro_cut {
    //    compatible = "zmk,behavior-macro";
    //    #binding-cells = <0>;
    //    bindings = <&kp LC(X)>;
    //    };
    //    macro_redo: macro_redo {
    //    compatible = "zmk,behavior-macro";
    //    #binding-cells = <0>;
    //    bindings = <&kp LC(Y)>;
    //    };
    //    macro_undo: macro_undo {
    //    compatible = "zmk,behavior-macro";
    //    #binding-cells = <0>;
    //    bindings = <&kp LC(Z)>;
    //    };
    };


    keymap {
        compatible = "zmk,keymap";


// GLOSSARY FOR KEY POSITIONS (todo: fill it in)
//=================================================================================================================================================================================================================
//
// 0       1                  2                3            4                  5                   (6)                         7                  8               9                 10           11             12
// 13      q(14)              w(15)            e(16)        r(17               t(18                (6)                       y(20                 u(0             i(22)            o(23)         p(0)           25
// 26      a                  s                d            f(30)              g(31)               (6)                       h(                  j(34)            k(35             l(36          37             38
// 39      z(40               x(41             c(42         v(43               b(44                (6)                       n(46                m(47             48               49            50             51 
//                                                                                                 (6)
//                                                     53 0           0  0  0                                              0 0 0             0 0
//=================================================================================================================================================================================================================




    layer0 {
    bindings = <

       &none  &none &none &none &none &none       &kp UP_ARROW           &none &none &none &none &none &none
            &kp ESC &kp Q &kp W &kp E &kp R &kp T  &kp UP_ARROW      &kp Y &kp U &kp I &kp O &kp P &kp DEL
            &mt LCTRL TAB &kp A &kp S &kp D &kp F &kp G  &kp LEFT_ARROW    &kp H &kp J &kp K &kp L &kp SEMI &mt RCTRL APOS
            &kp LSHIFT &kp Z &kp X &kp C &kp V &kp B  &kp RIGHT_ARROW   &kp N &kp M &mt RGUI COMMA &kp DOT &kp FSLH &kp RSHIFT
                                                  &kp C_MUTE
&none &mt LALT ESC &lt L_SYMNUM SPACE &lt L_NAV TAB  &none &kp ENTER  &none  &lt L_NAV ENTER &lt L_SYMNUM SPACE &mt RALT BACKSPACE &none

            >; display-name = "layer0"; sensor-bindings = <&inc_dec_kp C_VOLUME_UP C_VOL_DN>; };



    layer1 {
    bindings = <

       &none  &none &none &none &none &none       &kp UP_ARROW           &none &none &none &none &none &none
            &kp ESC &kp Q &kp W &kp E &kp R &kp T  &kp UP_ARROW      &kp Y &kp U &kp I &kp O &kp P &kp DEL
            &mt LCTRL TAB &kp A &kp S &kp D &kp F &kp G  &kp LEFT_ARROW    &kp H &kp J &kp K &kp L &kp SEMI &mt RCTRL APOS
            &kp LSHIFT &kp Z &kp X &kp C &kp V &kp B  &kp RIGHT_ARROW   &kp N &kp M &mt RGUI COMMA &kp DOT &kp FSLH &kp RSHIFT
                                                  &kp C_MUTE
&none &mt LALT ESC &lt L_SYMNUM SPACE &lt L_NAV TAB  &none &kp ENTER  &none  &lt L_NAV ENTER &lt L_SYMNUM SPACE &mt RALT BACKSPACE &none

            >; display-name = "layer1"; sensor-bindings = <&inc_dec_kp C_VOLUME_UP C_VOL_DN>; };



    };
};